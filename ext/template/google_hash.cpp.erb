#include <iostream>
#include <google/<%= type %>_hash_map>
#include <ruby.h>

// much code stolen shamelessly from lourens' cb gem

using google::<%= type %>_hash_map;      // namespace where class lives by default
using std::cout;
using std::endl;
<% if OS.linux? %>
  #include <ext/hash_set>
<% end %>
using __gnu_cxx::hash;  // or __gnu_cxx::hash, or maybe tr1::hash, depending on your OS
extern "C" {

// some helpers

struct eqstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return (s1 == s2) || (s1 && s2 && strcmp(s1, s2) == 0);
  }
};


struct eqrb
{
  bool operator()(const VALUE s1, const VALUE s2) const
  {
    if(s1 == s2) {
      return true;
    }
    return rb_eql(s1, s2); // this is eql? on them, basically
    // return RTEST(rb_funcall(obj1, id_eql, 1, obj2));
    // ugh
  }
};

struct hashrb
{
    size_t operator()(const VALUE hash_me) const
      {
        return rb_hash(hash_me);
      }
};



/* we end up not needing this...or at least not using it, I don't know if it would be faster than using the default or not
struct eqint
{
  inline bool operator()(int s1, int s2) const
  {
    return s1 == s2;
  }
};
*/


typedef struct {
  <%= type %>_hash_map< <%= key_type %>, <%= value_type %> <%= extra_hash_params %> > *hash_map;
} RCallback;


static VALUE rb_cGoogleHashLocal;

static void mark_hash_map_values(RCallback *incoming) {
  for(<%= type %>_hash_map< <%= key_type %>, <%= value_type %> <%= extra_hash_params %> >::iterator it = incoming->hash_map->begin(); it != incoming->hash_map->end(); ++it) {
     rb_gc_mark(it->second);
  }
}

static void free_hash_callback(RCallback* cb) {
  //  delete cb->hash_map;
}

static VALUE callback_alloc _((VALUE)); // what does this line do?

static VALUE
callback_alloc( VALUE klass )
{
    VALUE cb;
    RCallback* cbs;
    cb = Data_Make_Struct(klass, RCallback, mark_hash_map_values, free_hash_callback, cbs);
    cbs->hash_map = new <%= type %>_hash_map< <%= key_type %>, <%= value_type %> <%= extra_hash_params %> >();
    <% if setup_code %>
	     cbs->hash_map-><%= setup_code %>;
    <% end %> 
    return cb;
}


#define GetCallbackStruct(obj)	(Check_Type(obj, T_DATA), (RCallback*)DATA_PTR(obj))


static VALUE
rb_mri_hash_new(VALUE freshly_created) {

  // we don't actually have anything special to do here...
  // unless someone subclassed us or something [?]
  // ltodo test
  return freshly_created;
}


static VALUE rb_ghash_set(VALUE cb, VALUE set_this, VALUE to_this) {
  <% if assert_key_type %>
    if(!(TYPE(set_this) == <%= assert_key_type %>)) {
       rb_raise(rb_eTypeError, "not valid value #{assert_key_type}");
    }
  <% end %>
  RCallback* cbs = GetCallbackStruct(cb);
  (*cbs->hash_map)[ <%= convert_keys_from_ruby %>(set_this)] = to_this;  
  return to_this; // ltodo test that it returns value...
}

static VALUE rb_ghash_get(VALUE cb, VALUE get_this) {
  // TODO optionally not assert [?]
  <% if assert_key_type %>
    if(!(TYPE(get_this) == <%= assert_key_type %>)) {
       rb_raise(rb_eTypeError, "not valid value #{assert_key_type}");
    }
  <% end %>
  RCallback* cbs = GetCallbackStruct(cb);
  VALUE out = (*cbs->hash_map)[ <%= convert_keys_from_ruby %>(get_this)];
  if(out == NULL) { // not found...hmm...
    return Qnil;
  }
  return out;
}

static VALUE rb_ghash_each(VALUE cb) {
    RCallback* incoming = GetCallbackStruct(cb);
    for(<%= type %>_hash_map< <%= key_type %>, <%= value_type %> <%= extra_hash_params %> >::iterator it = incoming->hash_map->begin(); it != incoming->hash_map->end(); ++it) {
      rb_yield_values(2, <%= convert_keys_to_ruby %>(it->first), it->second);
    }
    return cb;  
}
  
static VALUE rb_ghash_values(VALUE cb) {
    RCallback* incoming = GetCallbackStruct(cb);
    VALUE out = rb_ary_new2(incoming->hash_map->size());
     for(<%= type %>_hash_map< <%= key_type %>, <%= value_type %> <%= extra_hash_params %>  >::iterator it = incoming->hash_map->begin(); it != incoming->hash_map->end(); ++it) {
      rb_ary_push(out, it->second);
    } 
    return out;
}
  
static VALUE rb_ghash_keys(VALUE cb) {
    RCallback* incoming = GetCallbackStruct(cb);
    VALUE out = rb_ary_new2(incoming->hash_map->size());
     for(<%= type %>_hash_map< <%= key_type %>, <%= value_type %> <%= extra_hash_params %> >::iterator it = incoming->hash_map->begin(); it != incoming->hash_map->end(); ++it) {
      rb_ary_push(out, <%= convert_keys_to_ruby %>(it->first));
    } 
    return out;
}

void init_<%= type %>_<%= english_key_type %>_to_<%= english_value_type %>() {
    rb_cGoogleHashLocal = rb_define_class("GoogleHash<%= type.capitalize %><%= english_key_type.capitalize %>To<%= english_value_type.capitalize %>", rb_cObject);

    rb_define_alloc_func(rb_cGoogleHashLocal, callback_alloc); // I guess it calls this for us, pre initialize... 

    rb_define_method(rb_cGoogleHashLocal, "initialize", RUBY_METHOD_FUNC(rb_mri_hash_new), 0); 
    rb_define_method(rb_cGoogleHashLocal, "[]=", RUBY_METHOD_FUNC(rb_ghash_set), 2); 
    rb_define_method(rb_cGoogleHashLocal, "[]", RUBY_METHOD_FUNC(rb_ghash_get), 1); 
    rb_define_method(rb_cGoogleHashLocal, "each", RUBY_METHOD_FUNC(rb_ghash_each), 0);
    rb_define_method(rb_cGoogleHashLocal, "values", RUBY_METHOD_FUNC(rb_ghash_values), 0); 
    rb_define_method(rb_cGoogleHashLocal, "keys", RUBY_METHOD_FUNC(rb_ghash_keys), 0); 

  } 
}

